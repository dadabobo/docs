## Docker Basic
###### 基本概念
Docker 包括三个基本概念
* 镜像（Image）  
  Docker 镜像就是一个只读的模板。镜像可以用来创建 Docker 容器。
  Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。
* 容器（Container）  
  Docker 利用容器来运行应用。
  容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。
  可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。
  镜像是只读的，容器在启动的时候创建一层可写层作为最上层。
* 仓库（Repository）  
  仓库是集中存放镜像文件的场所。
  有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的 标签（tag）。
  仓库分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。
  用户也可以在本地网络内创建一个私有仓仓库集中存放镜像文件。
  当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。

理解了这三个概念，就理解了 Docker 的整个生命周期。

###### 使用Docker容器应该避免的10个事情
当你最后投入容器的怀抱，发现它能解决很多问题，而且还具有众多的优点:
* 第一：它是不可变的 – 操作系统，库版本，配置，文件夹和应用都是一样的。您可以使用通过相同QA测试的镜像，使产品具有相同的表现。
* 第二：它是轻量级的 – 容器的内存占用非常小。不需要几百几千 MB，它只要对主进程分配内存再加上几十 MB。
* 第三：它很快速 – 启动一个容器与启动一个单进程一样快。不需要几分钟，您可以在几秒钟内启动一个全新的容器。

但是，许多用户依然像对待典型的虚拟机那样对待容器。但是他们都忘记了除了与虚拟机相似的部分，容器还有一个很大的优点：它是一次性的。

###### 容器的准则：“容器是临时的”
这个特性“本身”促使用户改变他们关于使用和管理容器的习惯；我将会向您解释在容器中不应该做这些事，以确保最大地发挥容器的作用。
1. **不要在容器中存储数据** – 容器可能被停止，销毁，或替换。一个运行在容器中的程序版本 1.0，应该很容易被 1.1 的版本替换且不影响或损失数据。有鉴于此，如果你需要存储数据，请存在卷中，并且注意如果两个容器在同一个卷上写数据会导致崩溃。确保你的应用被设计成在共享数据存储上写入。
2. **不要将你的应用发布两份** – 一些人将容器视为虚拟机。他们中的大多数倾向于认为他们应该在现有的运行容器里发布自己的应用。在开发阶段这样是对的，此时你需要不断地部署与调试；但对于质量保证与生产中的一个连续部署的管道，你的应用本该成为镜像的一部分。记住：容器应该保持不变。
3. **不要创建超大镜像** – 一个超大镜像只会难以分发。确保你仅有运行你应用/进程的必需的文件和库。不要安装不必要的包或在创建中运行更新（yum 更新）。
4. **不要使用单层镜像** – 要对分层文件系统有更合理的使用，始终为你的操作系统创建你自己的基础镜像层，另外一层为安全和用户定义，一层为库的安装，一层为配置，最后一层为应用。这将易于重建和管理一个镜像，也易于分发。
5. **不要为运行中的容器创建镜像** – 换言之，不要使用“docker commit”命令来创建镜像。这种创建镜像的方法是不可重现的也不能版本化，应该彻底避免。始终使用 Dockerfile 或任何其他的可完全重现的 S2I（源至镜像）方法。
6. **不要只使用“最新”标签** – 最新标签就像 Maven 用户的“快照”。标签是被鼓励使用的，尤其是当你有一个分层的文件系统。你总不希望当你 2 个月之后创建镜像时，惊讶地发现你的应用无法运行，因为最顶的分层被非向后兼容的新版本替换，或者创建缓存中有一个错误的“最新”版本。在生产中部署容器时应避免使用最新。
7. **不要在单一容器中运行超过一个进程** – 容器能完美地运行单个进程（http 守护进程，应用服务器，数据库），但是如果你不止有一个进程，管理、获取日志、独立更新都会遇到麻烦。
8. **不要在镜像中存储凭据**。使用环境变量 –不要将镜像中的任何用户名/密码写死。使用环境变量来从容器外部获取此信息。有一个不错的例子是 postgres 镜像。
9. **使用非 root 用户运行进程** – “docker 容器默认以 root 运行。（…）随着 docker 的成熟，更多的安全默认选项变得可用。现如今，请求 root 对于其他人是危险的，可能无法在所有环境中可用。你的镜像应该使用 USER 指令来指令容器的一个非 root 用户来运行。”（来自 Docker 镜像作者指南）
10. **不要依赖 IP 地址** – 每个容器都有自己的内部 IP 地址，如果你启动并停止它地址可能会变化。如果你的应用或微服务需要与其他容器通讯，使用任何命名与（或者）环境变量来从一个容器传递合适信息到另一个。


###### Docker在开发和运维过程中的优势
随着公有云的发展成熟，对于开发者来说需要一个快速迁移和高速构建应用的环境。虽然公有云为我们提供了一个按需就绪的计算环境，但是开发环境的部署仍然不能敏捷化。这个时候需要一个能够忽略公有云底层架构的创建应用开发的方式，这就是容器虚拟化技术。
对于容器虚拟化技术，Docker就是代表。很多人会搞错，以为Docker就是容器技术，其实不是这样的。Docker只是容器技术的一种，这点需要首先搞明白。

对开发和运维(DevOps)人员来说，需要一种快速交付部署的应用模式。而Docker就是这样的一个工具。

Docker在开发和运维过程中，具有如下几个方面的优势。
* 更快速的交付和部署。使用Docker，开发人员可以使用镜像来快速构建一套标准的开发环境，而且在项目实施中，测试环境和生产环境可以实现持续集成。大量节约开发、测试、部署的时间。
* 更高效的资源利用。Docker容器不像虚拟机那样需要额外的管理程序，它依赖系统内核运行，所以在资源开销上比虚拟机那种形式要低很多。
* 更轻松的迁移和扩展。Docker容器几乎可以在跨操作系统、跨环境中运行，这样也就是实现了无缝迁移的效果。
* 更简单的更新管理。使用Dockerfile，可以代替以往的繁琐的更新，而且这些更新是可跟踪的，在开发环境中这种形式更为可靠。

###### 常见问题
* 使用Non root 用户  
  目前版本的docker由于使用Socket进行通讯，因此需要root用户权限 sudo xxx，或者将需要使用Docker client的用户加入docker用户组 `sudo gpasswd -a ${USER} docker`
* 网络相关问题  
  当你在网关背后需要通过代理连接docker的index数据库时，可以手动加上http_proxy环境变量来启动docker daemon  
  `HTTP_PROXY=http://proxy_server:port docker -d &`  
  更好的做法是修改`/etc/default/docker` (on ubuntu), 添加 `export http_proxy=proxy_server:port`
  同样，docker container 如果无法自动正确的从host环境中获得DNS的配置，则需要手动指定DNS服务器地址，这可以通过
  `docker -run --dns=xxx` 来实现，也可以修改`/etc/default/docker` 添加例如 `DOCKER_OPTS="-dns 8.8.8.8"`
* 特权模式  
  在正常情况下 在container内部你没有权限操作device设备，而当前版本中，container内部部分文件例如/etc/hosts;/etc/hostname; /etc/resolve.conf等文件是动态通过mount动态以只读的形式加载上来的，理论上说你应该找到合适的方法去保证这些自动生成并加载的文件的正确性 (例如 通过--dns 设置 resolve.conf )，但是如果由于特殊原因你需要手动修改，那么你可以通过特权模式启动 docker client ： docker run --privileged ，然后你可以卸载这些文件，自己再创建新的版本
* 过多的层级依赖关系  
  以Layer的方式实现APP和相关library的cheap reuse和fast update是Docker的关键所在，不过受目前AUFS文件系统的限制，默认Layer的层级最多只能达到127（曾经只有42），在实际使用中有多种情况可能导致你的container的层级关系快速增长到这个极限值，撇开这么多layer叠加以后AUFS的效率不谈，更多情况下是你无法再更新构建你的image了
  * 使用Dockerfile构建Image时，每条指令都会给最终的Image增加一层layer依赖关系.
  * 以修改，提交，再修改再提交的方式不停的调整，更新你的Image
  * 从仓库中下载的别人的Image已经包含众多的层级依赖关系，而你需要进一步更新以创建你自己的版本

  前两者在一定程度上还是你自己可能把控的，最后一种情况就没办法了。这个问题最终必将影响Docker的实际可用性，目前的解决方案包括：
  * 使用Dockerfile时,尽可能合并多个操作：例如使用 "&&" 或 ";"
  * 合并运行多个shell命令；将多个shell命令写成脚本，在dockerfile中添加并运行这个脚本
  * 通过Export再Import Image，丢弃所有历史信息和依赖关系，创建一个全新的image

  将来可能的解决方案包括：
  * 在Dockerfile中添加对多步操作的合并提交的支持
  * 外部的image Flat工具的支持，目标是能够保留历史信息等
  * 非AUFS的其它Storage解决方案
